---
title: "56, Beginner"
description: "160,000 lines of production code. Three years of building. Most days I still feel like a beginner. Some days that's a problem. Some days it's the point."
pubDate: 2026-01-13
---

I'm 56 years old. I'm building investment software, knowledge systems, and AI collaboration tools. 160,000 lines of production code and counting. I know more than I did three years ago. Most days I still feel like a beginner. Some days that's a problem. Some days it's the point.

## The Origin

When I started at University of Illinois, I knew I wanted to be an engineer. Top school, engineers got paid well, I was good with numbers. So I tried ceramic engineering. Then mechanical engineering. Both felt random. So many facts and specifics that didn't connect to anything larger.

I gave it some real thought. Why was I doing this? What did I actually want from four years of education?

I decided I wanted the fundamental tools required for life in human civilization. And I figured those tools were math and language. So I double-majored in philosophy and engineering physics. Philosophy: the application of language to difficult problems. Engineering physics: the application of math to difficult problems.

I didn't have a name for this approach then. Now I'd call it foundation-first.

## The Career

After graduation, I joined EDS as a "research systems engineer." The title sounds impressive until you learn it mostly meant data modeling and business process design. Which were new things then, hence the "research" part of the job title. That was my first exposure to formal "systems engineering."

At McKinsey, the same pattern. They wanted me to specialize. Pick an industry, build a spike. I resisted. I wanted to hone generalist problem-solving skills, not become the banking guy or the healthcare guy. The partners weren't thrilled. But I kept seeing business problems as systems problems, and engineering approaches kept working.

I didn't know I was training for anything. I just knew I wanted my learning to transfer.

## The Lost Years

Then I got sick.

From 2009 to the early 2020s, chronic illness. I won't go into details. That's a different story. What matters here: years of feeling useless. Failed business attempts. Not earning a living. Shame.

Part of the reason for this blog is to stop hiding.

## The Syntax Wall

When my health finally improved enough to try something new, I took CS50. I was 53. First code I'd written since college.

For two years after that, I fought the syntax. Every tutorial felt like a trap. Every package manager, a labyrinth. I could build "Hello World," but the moment complexity arrived, it crushed me.

The specific moment I remember: I was building a website in Next.js. HTML, CSS, Tailwind: those I could handle. Then I discovered page caching. Not just that it existed, but that I had control over it. That I *had* to control it, because performance depended on it.

That's when the complexity became overwhelming.

I realized shortly after that I didn't need Next.js at all. The world was going mobile-first. I needed a multi-platform stack. So I moved to Dart and Flutter.

The learning curve didn't flatten. It just reset.

## The Shift

Somewhere between 2023 and the first half of 2025, AI tools started to radically change what "learning to code" means.

In the early days, it was ChatGPT in a browser window, copy-pasting code back and forth. Primitive. But something was happening.

For me, the turning point was an experiment: AI-assisted journaling. I set it up as a Claude Code project. At first, the journal was boring. No memory between sessions. So I added persistent memory, copying files into the project knowledge. Over time, it got more structured. I learned what worked, what didn't.

And somewhere in that process, I recognized what I was doing.

This was systems work. Inputs, outputs, feedback loops, constraints. The same thing I'd been doing at EDS. At McKinsey. In my philosophy classes, applying language to hard problems.

I wasn't learning something new. I was recognizing something old.

Syntax was no longer the job. Structure was the job. And I already knew structure. I just hadn't known it was applicable to code.

## The Recognition

What did that recognition feel like?

Vindication. Relief.

After years of shame, years of feeling useless and unsuccessful, I discovered I had a certain amount of comfort in this wild new technology. Not because I was talented, but because decades of foundation-first thinking had prepared me for a technology that thrives and gets better when it has well-built foundations.

I always expected my learning to transfer. That was the whole point of choosing philosophy and engineering physics. Of resisting specialization. Of treating every problem as a system.

I just didn't know when or how.

## Foundation-First Today

The question now is different than it was: should I use an off-the-shelf package, or build my own?

With AI, building custom has become viable in ways it never was before. But pre-made packages often don't work for me. They've made their own foundational choices, and those choices don't align with mine.

Example: the first thing I built in my current system was the operating rules, the base instructions that shape every session. I spent weeks experimenting until I found an approach that felt right. I couldn't have done that with an off-the-shelf setup. Their foundations weren't my foundations.

In code, foundation-first means: write tests before features. Refactor as understanding deepens. Don't jump to advanced techniques before the fundamentals make sense.

It's slow. But (I hope) it's less likely to collapse under its own weight.

## Writing Is Thinking

My high school physics teacher, Mr. Horton, used to say: "If you're not writing, you're not thinking."

He was right. When I explain something, I see the gaps. My fuzzy thinking gets exposed. Then I can try to fix it.

This blog isn't documenting things I've figured out. It's figuring things out through writing. When I explain why an architectural choice makes sense, the pattern becomes clearer to me.

You're invited to watch me think.

## What You'll Find Here

I'll try to document the build as it happens. Architecture decisions: why I chose specific patterns, what worked, what failed. AI collaboration: where it shines, where human judgment is non-negotiable. The struggles. The messy middle.

You won't find expert advice. I'm not qualified to give it. You won't find best practices; I don't know them.

What you'll find is someone figuring it out in public. Someone who decided to stop hiding.

This is either profound or hilarious. Probably both.
